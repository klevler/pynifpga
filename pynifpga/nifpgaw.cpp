/*
	Copyright (c) 2014 Vincent Paeder
	
	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

 C++ wrapper for NI-FPGA driver.

 This wrapper translates the NI-FPGA C API to a C++ class.

 You need NiFpga.h generated by the NI-FPGA C Interface Generator.

*/

#include <iostream>
#include "nifpgaw.h"

nifpga::nifpga() {
	sessionHandle = 0;
	lastStatus = 0;
	sessionOpen = false;
	driverInitialized = false;
	Initialize();
}

nifpga::~nifpga() {
	if (sessionOpen) Close(sessionHandle);
	Finalize();
}

bool nifpga::HandleStatus(NiFpga_Status status) {
	lastStatus = status;
	if (status < 0) {
		std::cout << "[ERROR]: " << status << std::endl;
		std::cout << ErrorDescription(status) << std::endl;
		return false;
	}
	if (status > 0) {
		std::cout << "[WARNING]: " << status << std::endl;
	}
	return true;
}

char* nifpga::ErrorDescription(NiFpga_Status status) {
	if (status == -50400) return "The timeout expired before the FIFO operation could complete.";
	if (status == -50405) return "No transfer is in progress because the transfer was aborted by the client. The operation could not be completed as specified.";
	if (status == -52000) return "A memory allocation failed. Try again after rebooting.";
	if (status == -52003) return "An unexpected software error occurred.";
	if (status == -52005) return "A parameter to a function was not valid. This could be a NULL pointer, a bad value, etc.";
	if (status == -52006) return "A required resource was not found. The NiFpga.* library, the RIO resource, or some other resource may be missing.";
	if (status == -52010) return "A required resource was not properly initialized. This could occur if NiFpga_Initialize was not called or a required NiFpga_IrqContext was not reserved.";
	if (status == -52018) return "A hardware failure has occurred. The operation could not be completed as specified.";
	if (status == -61003) return "The FPGA is already running.";
	if (status == -61018) return "An error occurred downloading the VI to the FPGA device. Verify that the target is connected and powered and that the resource of the target is properly configured.";
	if (status == -61024) return "The bitfile was not compiled for the specified resource's device type.";
	if (status == -61046) return "An error was detected in the communication between the host computer and the FPGA target.";
	if (status == -61060) return "The timeout expired before any of the IRQs were asserted.";
	if (status == -61070) return "The specified bitfile is invalid or corrupt.";
	if (status == -61072) return "The requested FIFO depth is invalid. It is either 0 or an amount not supported by the hardware.";
	if (status == -61073) return "The number of FIFO elements is invalid. Either the number is greater than the depth of the host memory DMA FIFO, or more elements were requested for release than had been acquired.";
	if (status == -61083) return "A hardware clocking error occurred. A derived clock lost lock with its base clock during the execution of the LabVIEW FPGA VI. If any base clocks with derived clocks are referencing an external source, make sure that the external source is connected and within the supported frequency, jitter, accuracy, duty cycle, and voltage specifications. Also verify that the characteristics of the base clock match the configuration specified in the FPGA Base Clock Properties. If all base clocks with derived clocks are generated from free-running, on-board sources, please contact National Instruments technical support at ni.com/support.";
	if (status == -61141) return "The operation could not be performed because the FPGA is busy. Stop all activities on the FPGA before requesting this operation. If the target is in Scan Interface programming mode, put it in FPGA Interface programming mode.";
	if (status == -61200) return "The operation could not be performed because the FPGA is busy operating in FPGA Interface C API mode. Stop all activities on the FPGA before requesting this operation.";
	if (status == -61201) return "The chassis is in Scan Interface programming mode. In order to run FPGA VIs, you must go to the chassis properties page, select FPGA programming mode, and deploy settings.";
	if (status == -61201) return "The operation could not be performed because the FPGA is busy operating in FPGA Interface mode. Stop all activities on the FPGA before requesting this operation.";
	if (status == -61203) return "The operation could not be performed because the FPGA is busy operating in Interactive mode. Stop all activities on the FPGA before requesting this operation.";
	if (status == -61204) return "The operation could not be performed because the FPGA is busy operating in Emulation mode. Stop all activities on the FPGA before requesting this operation.";
	if (status == -61211) return "LabVIEW FPGA does not support the Reset method for bitfiles that allow removal of implicit enable signals in single-cycle Timed Loops.";
	if (status == -61212) return "LabVIEW FPGA does not support the Abort method for bitfiles that allow removal of implicit enable signals in single-cycle Timed Loops.";
	if (status == -61213) return "LabVIEW FPGA does not support Close and Reset if Last Reference for bitfiles that allow removal of implicit enable signals in single-cycle Timed Loops. Pass the NiFpga_CloseAttribute_NoResetIfLastSession attribute to NiFpga_Close instead of 0.";
	if (status == -61214) return "For bitfiles that allow removal of implicit enable signals in single-cycle Timed Loops, LabVIEW FPGA does not support this method prior to running the bitfile.";
	if (status == -61215) return "Bitfiles that allow removal of implicit enable signals in single-cycle Timed Loops can run only once. Download the bitfile again before re-running the VI.";
	if (status == -61216) return "A gated clock has violated the handshaking protocol. If you are using external gated clocks, ensure that they follow the required clock gating protocol. If you are generating your clocks internally, please contact National Instruments Technical Support.";
	if (status == -61219) return "The number of elements requested must be less than or equal to the number of unacquired elements left in the host memory DMA FIFO. There are currently fewer unacquired elements left in the FIFO than are being requested. Release some acquired elements before acquiring more elements.";
	if (status == -61499) return "An unexpected internal error occurred.";
	if (status == -63003) return "The NI-RIO driver was unable to allocate memory for a FIFO. This can happen when the combined depth of all DMA FIFOs exceeds the maximum depth for the controller, or when the controller runs out of system memory. You may be able to reconfigure the controller with a greater maximum FIFO depth. For more information, refer to the NI KnowledgeBase article 65OF2ERQ.";
	if (status == -63033) return "Access to the remote system was denied. Use MAX to check the Remote Device Access settings under Software>>NI-RIO>>NI-RIO Settings on the remote system.";
	if (status == -63038) return "The NI-RIO software on the host is not compatible with the software on the target. Upgrade the NI-RIO software on the host in order to connect to this target.";
	if (status == -63040) return "A connection could not be established to the specified remote device. Ensure that the device is on and accessible over the network, that NI-RIO software is installed, and that the RIO server is running and properly configured.";
	if (status == -63043) return "The RPC session is invalid. The target may have reset or been rebooted. Check the network connection and retry the operation.";
	if (status == -63082) return "The operation could not complete because another session is accessing the FIFO. Close the other session and retry.";
	if (status == -63083) return "A Configure FIFO, Stop FIFO, Read FIFO, or Write FIFO function was called while the host had acquired elements of the FIFO. Release all acquired elements before configuring, stopping, reading, or writing.";
	if (status == -63084) return "A function was called using a misaligned address. The address must be a multiple of the size of the datatype.";
	if (status == -63085) return "The FPGA Read/Write Control Function is accessing a control or indicator with data that exceeds the maximum size supported on the current target. Refer to the hardware documentation for the limitations on data types for this target.";
	if (status == -63101) return "A valid .lvbitx bitfile is required. If you are using a valid .lvbitx bitfile, the bitfile may not be compatible with the software you are using. Determine which version of LabVIEW was used to make the bitfile, update your software to that version or later, and try again.";
	if (status == -63106) return "The specified signature does not match the signature of the bitfile. If the bitfile has been recompiled, regenerate the C API and rebuild the application.";
	if (status == -63107) return "The bitfile you are trying to use is incompatible with the version of NI-RIO installed on the target and/or host. Update the version of NI-RIO on the target and/or host to the same version (or later) used to compile the bitfile. Alternatively, recompile the bitfile with the same version of NI-RIO that is currently installed on the target and/or host.";
	if (status == -63192) return "Either the supplied resource name is invalid as a RIO resource name, or the device was not found. Use MAX to find the proper resource name for the intended device.";
	if (status == -63193) return "The requested feature is not supported.";
	if (status == -63194) return "The NI-RIO software on the target system is not compatible with this software. Upgrade the NI-RIO software on the target system.";
	if (status == -63195) return "The session is invalid or has been closed.";
	if (status == -63198) return "The maximum number of open FPGA sessions has been reached. Close some open sessions.";
	return "Not a recognized error code.";
}

NiFpga_Status nifpga::GetLastStatus() {
	return lastStatus;
}

bool nifpga::Initialize() {
	bool status = false;
	if (!driverInitialized) status = HandleStatus(NiFpga_Initialize());
	if (status) driverInitialized = true;
	return status;
}

bool nifpga::Finalize() {
	bool status = false;
	if (driverInitialized) status = HandleStatus(NiFpga_Finalize());
	if (status) driverInitialized = false;
	return status;
}

bool nifpga::Open(char* bitfile, char* signature, char* resource, uint32_t attribute) {
	bool status = false;
	if (driverInitialized && !sessionOpen) status = HandleStatus(NiFpga_Open(bitfile, signature, resource, attribute, &sessionHandle));
	if (status) sessionOpen = true;
	return status;
}

bool nifpga::Close(uint32_t attribute) {
	bool status = false;
	if (sessionOpen) {
		if (sessionRunning) status = Abort();
		status = HandleStatus(NiFpga_Close(sessionHandle,attribute));
		if (status) sessionOpen = false;
	}
	return status;
}

bool nifpga::Run(uint32_t attribute) {
	bool status = false;
	if (sessionOpen && !sessionRunning) status = HandleStatus(NiFpga_Run(sessionHandle, attribute));
	if (status) sessionRunning = true;
	return status;
}

bool nifpga::Abort() {
	bool status = false;
	if (sessionOpen && sessionRunning) status = HandleStatus(NiFpga_Abort(sessionHandle));
	if (status) sessionRunning = false;
	return status;
}

bool nifpga::Reset() {
	bool status = false;
	if (sessionOpen) status = HandleStatus(NiFpga_Reset(sessionHandle));
	return status;
}

bool nifpga::Download() {
	bool status = false;
	if (sessionOpen) status = HandleStatus(NiFpga_Download(sessionHandle));
	if (status) sessionRunning = false;
	return status;
}

bool nifpga::ReadBool(uint32_t indicator, NiFpga_Bool* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadBool(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadI8(uint32_t indicator, int8_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadI8(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadU8(uint32_t indicator, uint8_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadU8(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadI16(uint32_t indicator, int16_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadI16(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadU16(uint32_t indicator, uint16_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadU16(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadI32(uint32_t indicator, int32_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadI32(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadU32(uint32_t indicator, uint32_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadU32(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadI64(uint32_t indicator, int64_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadI64(sessionHandle, indicator, value));
	return false;
}

bool nifpga::ReadU64(uint32_t indicator, uint64_t* value) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadU64(sessionHandle, indicator, value));
	return false;
}

bool nifpga::WriteBool(uint32_t control, NiFpga_Bool value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteBool(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteI8(uint32_t control, int8_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteI8(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteU8(uint32_t control, uint8_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteU8(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteI16(uint32_t control, int16_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteI16(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteU16(uint32_t control, uint16_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteU16(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteI32(uint32_t control, int32_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteI32(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteU32(uint32_t control, uint32_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteU32(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteI64(uint32_t control, int64_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteI64(sessionHandle, control, value));
	return false;
}

bool nifpga::WriteU64(uint32_t control, uint64_t value) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteU64(sessionHandle, control, value));
	return false;
}

bool nifpga::ReadArrayBool(uint32_t indicator, NiFpga_Bool* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayBool(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayI8(uint32_t indicator, int8_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayI8(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayU8(uint32_t indicator, uint8_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayU8(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayI16(uint32_t indicator, int16_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayI16(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayU16(uint32_t indicator, uint16_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayU16(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayI32(uint32_t indicator, int32_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayI32(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayU32(uint32_t indicator, uint32_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayU32(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayI64(uint32_t indicator, int64_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayI64(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::ReadArrayU64(uint32_t indicator, uint64_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_ReadArrayU64(sessionHandle, indicator, values, size));
	return false;
}

bool nifpga::WriteArrayBool(uint32_t control, const NiFpga_Bool* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayBool(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayI8(uint32_t control, const int8_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayI8(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayU8(uint32_t control, const uint8_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayU8(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayI16(uint32_t control, const int16_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayI16(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayU16(uint32_t control, const uint16_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayU16(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayI32(uint32_t control, const int32_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayI32(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayU32(uint32_t control, const uint32_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayU32(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayI64(uint32_t control, const int64_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayI64(sessionHandle, control, values, size));
	return false;
}

bool nifpga::WriteArrayU64(uint32_t control, const uint64_t* values, size_t size) {
	if (sessionOpen) return HandleStatus(NiFpga_WriteArrayU64(sessionHandle, control, values, size));
	return false;
}

bool nifpga::ReserveIrqContext(NiFpga_IrqContext* context) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReserveIrqContext(sessionHandle, context));
	return false;
}

bool nifpga::UnreserveIrqContext(NiFpga_IrqContext context) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_UnreserveIrqContext(sessionHandle, context));
	return false;
}

bool nifpga::WaitOnIrqs(NiFpga_IrqContext context, uint32_t irqs, uint32_t timeout, uint32_t* irqsAsserted, NiFpga_Bool* timedOut) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WaitOnIrqs(sessionHandle, context, irqs, timeout, irqsAsserted, timedOut));
	return false;
}

bool nifpga::AcknowledgeIrqs(uint32_t irqs) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcknowledgeIrqs(sessionHandle, irqs));
	return false;
}

bool nifpga::ConfigureFifo(uint32_t fifo, size_t depth) {
	if (sessionOpen) return HandleStatus(NiFpga_ConfigureFifo(sessionHandle, fifo, depth));
	return false;
}

bool nifpga::ConfigureFifo(uint32_t fifo, size_t requestedDepth, size_t* actualDepth) {
	if (sessionOpen) return HandleStatus(NiFpga_ConfigureFifo2(sessionHandle, fifo, requestedDepth, actualDepth));
	return false;
}

bool nifpga::StartFifo(uint32_t fifo) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_StartFifo(sessionHandle, fifo));
	return false;
}

bool nifpga::StopFifo(uint32_t fifo) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_StopFifo(sessionHandle, fifo));
	return false;
}

bool nifpga::ReadFifoBool(uint32_t fifo, NiFpga_Bool* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoBool(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoI8(uint32_t fifo, int8_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoI8(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoU8(uint32_t fifo, uint8_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoU8(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoI16(uint32_t fifo, int16_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoI16(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoU16(uint32_t fifo, uint16_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoU16(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoI32(uint32_t fifo, int32_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoI32(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoU32(uint32_t fifo, uint32_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoU32(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoI64(uint32_t fifo, int64_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoI64(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::ReadFifoU64(uint32_t fifo, uint64_t* data, size_t numberOfElements, uint32_t timeout, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReadFifoU64(sessionHandle, fifo, data, numberOfElements, timeout, elementsRemaining));
	return false;
}

bool nifpga::WriteFifoBool(uint32_t fifo, NiFpga_Bool* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoBool(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoI8(uint32_t fifo, int8_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoI8(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoU8(uint32_t fifo, uint8_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoU8(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoI16(uint32_t fifo, int16_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoI16(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoU16(uint32_t fifo, uint16_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoU16(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoI32(uint32_t fifo, int32_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoI32(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoU32(uint32_t fifo, uint32_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoU32(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoI64(uint32_t fifo, int64_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoI64(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::WriteFifoU64(uint32_t fifo, uint64_t* data, size_t numberOfElements, uint32_t timeout, size_t* emptyElementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_WriteFifoU64(sessionHandle, fifo, data, numberOfElements, timeout, emptyElementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsBool(uint32_t fifo, NiFpga_Bool** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsBool(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsI8(uint32_t fifo, int8_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsI8(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsU8(uint32_t fifo, uint8_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsU8(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsI16(uint32_t fifo, int16_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsI16(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsU16(uint32_t fifo, uint16_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsU16(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsI32(uint32_t fifo, int32_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsI32(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsU32(uint32_t fifo, uint32_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsU32(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsI64(uint32_t fifo, int64_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsI64(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoReadElementsU64(uint32_t fifo, uint64_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoReadElementsU64(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsBool(uint32_t fifo, NiFpga_Bool** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsBool(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsI8(uint32_t fifo, int8_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsI8(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsU8(uint32_t fifo, uint8_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsU8(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsI16(uint32_t fifo, int16_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsI16(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsU16(uint32_t fifo, uint16_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsU16(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsI32(uint32_t fifo, int32_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsI32(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsU32(uint32_t fifo, uint32_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsU32(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsI64(uint32_t fifo, int64_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsI64(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::AcquireFifoWriteElementsU64(uint32_t fifo, uint64_t** elements, size_t elementsRequested, uint32_t timeout, size_t* elementsAcquired, size_t* elementsRemaining) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_AcquireFifoWriteElementsU64(sessionHandle, fifo, elements, elementsRequested, timeout, elementsAcquired, elementsRemaining));
	return false;
}

bool nifpga::ReleaseFifoElements(uint32_t fifo, size_t elements) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_ReleaseFifoElements(sessionHandle, fifo, elements));
	return false;
}

bool nifpga::GetPeerToPeerFifoEndpoint(uint32_t fifo, uint32_t* endpoint) {
	if (sessionOpen && sessionRunning) return HandleStatus(NiFpga_GetPeerToPeerFifoEndpoint(sessionHandle, fifo, endpoint));
	return false;
}
