/*
	Copyright (c) 2014 Vincent Paeder
	
	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/

/*

 Python wrapper for NI-FPGA driver.

 This wrapper translates the NI-FPGA C API to python.

 You need NiFpga.h generated by the NI-FPGA C Interface Generator.

*/

#include "pynifpga.h"
#include <iostream>

pynifpga::pynifpga() {}
pynifpga::~pynifpga() {}

list pynifpga::ArrayExportBool(NiFpga_Bool* arr, int N) {
		//int N = sizeof(arr)+1;
		list data;
		for ( int i = 0; i < N; i++ ) {
			data.append(arr[i]);
		}
		return data;
}

list pynifpga::ArrayExportI8(int8_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportU8(uint8_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportI16(int16_t* arr, int N) {
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportU16(uint16_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportI32(int32_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportU32(uint32_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportI64(int64_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

list pynifpga::ArrayExportU64(uint64_t* arr, int N) {
	//int N = sizeof(arr)+1;
	list data;
	for (int i = 0; i < N; i++) {
		data.append(arr[i]);
	}
	return data;
}

NiFpga_Bool* pynifpga::ArrayImportBool(list arr) {
	NiFpga_Bool *data = new NiFpga_Bool[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (NiFpga_Bool)extract<bool>(arr[i]);
	}
	return data;
}

int8_t* pynifpga::ArrayImportI8(list arr) {
	int8_t *data = new int8_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (int8_t)extract<int>(arr[i]);
	}
	return data;
}

uint8_t* pynifpga::ArrayImportU8(list arr) {
	uint8_t *data = new uint8_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (uint8_t)extract<int>(arr[i]);
	}
	return data;
}

int16_t* pynifpga::ArrayImportI16(list arr) {
	int16_t *data = new int16_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (int16_t)extract<int>(arr[i]);
	}
	return data;
}

uint16_t* pynifpga::ArrayImportU16(list arr) {
	uint16_t *data = new uint16_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (uint16_t)extract<int>(arr[i]);
	}
	return data;
}

int32_t* pynifpga::ArrayImportI32(list arr) {
	int32_t *data = new int32_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (int32_t)extract<int>(arr[i]);
	}
	return data;
}

uint32_t* pynifpga::ArrayImportU32(list arr) {
	uint32_t *data = new uint32_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (uint32_t)extract<int>(arr[i]);
	}
	return data;
}

int64_t* pynifpga::ArrayImportI64(list arr) {
	int64_t *data = new int64_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (int64_t)extract<int>(arr[i]);
	}
	return data;
}

uint64_t* pynifpga::ArrayImportU64(list arr) {
	uint64_t *data = new uint64_t[len(arr)];
	for (int i = 0; i < len(arr); i++) {
		data[i] = (uint64_t)extract<int>(arr[i]);
	}
	return data;
}

int pynifpga::GetLastStatus() {
	return (int)fpga.GetLastStatus();
}

std::string pynifpga::GetErrorDescription(int status) {
	return (std::string)fpga.ErrorDescription((NiFpga_Status)status);
}

bool pynifpga::Initialize() { return fpga.Initialize(); }
bool pynifpga::Finalize() { return fpga.Finalize(); }

bool pynifpga::Open(std::string bitfile, std::string signature, std::string resource, int attribute) {
	char* bf = new char[256];
	char* sig = new char[256];
	char* res = new char[256];
	memcpy(bf, bitfile.c_str(), strlen(bitfile.c_str()) + 1);
	memcpy(sig, signature.c_str(), strlen(signature.c_str()) + 1);
	memcpy(res, resource.c_str(), strlen(resource.c_str()) + 1);
	if (fpga.Open(bf, sig, res, (uint32_t)attribute)) {
		loadedBitfile = bitfile;
		deviceHandle = resource;
		return true;
	}
	return false;
}

bool pynifpga::Close(int attribute) {
	if (fpga.Close((uint32_t)attribute)) {
		loadedBitfile = "";
		deviceHandle = "";
		return true;
	}
	return false;
}

bool pynifpga::Run(int attribute) { return fpga.Run((uint32_t)attribute); }

bool pynifpga::Abort() { return fpga.Abort(); }
bool pynifpga::Reset() { return fpga.Reset(); }

bool pynifpga::Download() { return fpga.Download(); }

bool pynifpga::ReadBool(int indicator) {
	NiFpga_Bool value;
	if (fpga.ReadBool((uint32_t)indicator, &value)) return (bool)value;
	return false;
}

int pynifpga::ReadI8(int indicator) {
	int8_t value;
	if (fpga.ReadI8((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadU8(int indicator) {
	uint8_t value;
	if (fpga.ReadU8((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadI16(int indicator) {
	int16_t value;
	if (fpga.ReadI16((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadU16(int indicator) {
	uint16_t value;
	if (fpga.ReadU16((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadI32(int indicator) {
	int32_t value;
	if (fpga.ReadI32((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadU32(int indicator) {
	uint32_t value;
	if (fpga.ReadU32((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadI64(int indicator) {
	int64_t value;
	if (fpga.ReadI64((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

int pynifpga::ReadU64(int indicator) {
	uint64_t value;
	if (fpga.ReadU64((uint32_t)indicator, &value)) return (int)value;
	return 0;
}

bool pynifpga::WriteBool(int control, bool value) { 
	return fpga.WriteBool((uint32_t)control, (NiFpga_Bool)value); 
}

bool pynifpga::WriteI8(int control, int value) {
	return fpga.WriteI8((uint32_t)control, (int8_t)value); 
}

bool pynifpga::WriteU8(int control, int value) {
	return fpga.WriteU8((uint32_t)control, (uint8_t)value);
}

bool pynifpga::WriteI16(int control, int value) {
	return fpga.WriteI16((uint32_t)control, (int16_t)value);
}

bool pynifpga::WriteU16(int control, int value) {
	return fpga.WriteU16((uint32_t)control, (uint16_t)value);
}

bool pynifpga::WriteI32(int control, int value) {
	return fpga.WriteI32((uint32_t)control, (int32_t)value);
}

bool pynifpga::WriteU32(int control, int value) {
	return fpga.WriteU32((uint32_t)control, (uint32_t)value);
}

bool pynifpga::WriteI64(int control, int value) {
	return fpga.WriteI64((uint32_t)control, (int64_t)value);
}

bool pynifpga::WriteU64(int control, int value) {
	return fpga.WriteU64((uint32_t)control, (uint64_t)value);
}

list pynifpga::ReadArrayBool(int indicator, int size) {
	NiFpga_Bool *values = new NiFpga_Bool[size];
	list emptyList;
	if (fpga.ReadArrayBool((uint32_t)indicator, values, (size_t)size)) return ArrayExportBool(values, size);
	return emptyList;
}

list pynifpga::ReadArrayI8(int indicator, int size) {
	int8_t *values = new int8_t[size];
	list emptyList;
	if (fpga.ReadArrayI8((uint32_t)indicator, values, (size_t)size)) return ArrayExportI8(values, size);
	return emptyList;
}

list pynifpga::ReadArrayU8(int indicator, int size) {
	uint8_t *values = new uint8_t[size];
	list emptyList;
	if (fpga.ReadArrayU8((uint32_t)indicator, values, (size_t)size)) return ArrayExportU8(values, size);
	return emptyList;
}

list pynifpga::ReadArrayI16(int indicator, int size) {
	int16_t *values = new int16_t[size];
	list emptyList;
	if (fpga.ReadArrayI16((uint32_t)indicator, values, (size_t)size)) return ArrayExportI16(values, size);
	return emptyList;
}

list pynifpga::ReadArrayU16(int indicator, int size) {
	uint16_t *values = new uint16_t[size];
	list emptyList;
	if (fpga.ReadArrayU16((uint32_t)indicator, values, (size_t)size)) return ArrayExportU16(values, size);
	return emptyList;
}

list pynifpga::ReadArrayI32(int indicator, int size) {
	int32_t *values = new int32_t[size];
	list emptyList;
	if (fpga.ReadArrayI32((uint32_t)indicator, values, (size_t)size)) return ArrayExportI32(values, size);
	return emptyList;
}

list pynifpga::ReadArrayU32(int indicator, int size) {
	uint32_t *values = new uint32_t[size];
	list emptyList;
	if (fpga.ReadArrayU32((uint32_t)indicator, values, (size_t)size)) return ArrayExportU32(values, size);
	return emptyList;
}

list pynifpga::ReadArrayI64(int indicator, int size) {
	int64_t *values = new int64_t[size];
	list emptyList;
	if (fpga.ReadArrayI64((uint32_t)indicator, values, (size_t)size)) return ArrayExportI64(values, size);
	return emptyList;
}

list pynifpga::ReadArrayU64(int indicator, int size) {
	uint64_t *values = new uint64_t[size];
	list emptyList;
	if (fpga.ReadArrayU64((uint32_t)indicator, values, (size_t)size)) return ArrayExportU64(values, size);
	return emptyList;
}

bool pynifpga::WriteArrayBool(int control, list values) {
	return fpga.WriteArrayBool((uint32_t)control, ArrayImportBool(values), (size_t)len(values));
}

bool pynifpga::WriteArrayI8(int control, list values) {
	return fpga.WriteArrayI8((uint32_t)control, ArrayImportI8(values), (size_t)len(values));
}

bool pynifpga::WriteArrayU8(int control, list values) {
	return fpga.WriteArrayU8((uint32_t)control, ArrayImportU8(values), (size_t)len(values));
}

bool pynifpga::WriteArrayI16(int control, list values) {
	return fpga.WriteArrayI16((uint32_t)control, ArrayImportI16(values), (size_t)len(values));
}

bool pynifpga::WriteArrayU16(int control, list values) {
	return fpga.WriteArrayU16((uint32_t)control, ArrayImportU16(values), (size_t)len(values));
}

bool pynifpga::WriteArrayI32(int control, list values) {
	return fpga.WriteArrayI32((uint32_t)control, ArrayImportI32(values), (size_t)len(values));
}

bool pynifpga::WriteArrayU32(int control, list values) {
	return fpga.WriteArrayU32((uint32_t)control, ArrayImportU32(values), (size_t)len(values));
}

bool pynifpga::WriteArrayI64(int control, list values) {
	return fpga.WriteArrayI64((uint32_t)control, ArrayImportI64(values), (size_t)len(values));
}

bool pynifpga::WriteArrayU64(int control, list values) {
	return fpga.WriteArrayU64((uint32_t)control, ArrayImportU64(values), (size_t)len(values));
}

PyObject* pynifpga::ReserveIrqContext() {
	NiFpga_IrqContext irqContext;
	PyObject* retval;
	if (fpga.ReserveIrqContext(&irqContext)) {
		retval = PyCObject_FromVoidPtr(irqContext, NULL);
	}
	else {
		retval = Py_BuildValue("O", 0);
	}
	return retval;
}

bool pynifpga::UnreserveIrqContext(PyObject* context) {
	return fpga.UnreserveIrqContext(PyCObject_AsVoidPtr(context));
}

bool pynifpga::WaitOnIrqs(PyObject* context, int irqs, int timeout) {
	uint32_t irqsAsserted;
	NiFpga_Bool timedOut;
	bool status;
	status = fpga.WaitOnIrqs(PyCObject_AsVoidPtr(context), (uint32_t)irqs, (uint32_t)timeout, &irqsAsserted, &timedOut);
	return status && (bool)timedOut;
}

bool pynifpga::AcknowledgeIrqs(int irqs) {
	return fpga.AcknowledgeIrqs((uint32_t)irqs);
}

bool pynifpga::ConfigureFifo(int fifo, int requestedDepth) {
	bool status;
	size_t actualDepth = 0;
	status = fpga.ConfigureFifo((uint32_t)fifo, (size_t)requestedDepth, &actualDepth);
	return status && (actualDepth == requestedDepth);
}

bool pynifpga::StartFifo(int fifo) {
	return fpga.StartFifo((uint32_t)fifo);
}

bool pynifpga::StopFifo(int fifo) {
	return fpga.StopFifo((uint32_t)fifo);
}

list pynifpga::ReadFifoBool(int fifo, int numberOfElements, int timeout) {
	NiFpga_Bool* data = new NiFpga_Bool[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoBool((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportBool(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoBool((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoI8(int fifo, int numberOfElements, int timeout) {
	int8_t* data = new int8_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoI8((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportI8(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoI8((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoU8(int fifo, int numberOfElements, int timeout) {
	uint8_t* data = new uint8_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoU8((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportU8(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoU8((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoI16(int fifo, int numberOfElements, int timeout) {
	int16_t* data = new int16_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoI16((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportI16(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoI16((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoU16(int fifo, int numberOfElements, int timeout) {
	uint16_t* data = new uint16_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoU16((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportU16(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoU16((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoI32(int fifo, int numberOfElements, int timeout) {
	int32_t* data = new int32_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoI32((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportI32(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoI32((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoU32(int fifo, int numberOfElements, int timeout) {
	uint32_t* data = new uint32_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoU32((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportU32(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoU32((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoI64(int fifo, int numberOfElements, int timeout) {
	int64_t* data = new int64_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoI64((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportI64(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoI64((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

list pynifpga::ReadFifoU64(int fifo, int numberOfElements, int timeout) {
	uint64_t* data = new uint64_t[numberOfElements];
	size_t elementsRemaining;
	if (numberOfElements > 0) {
		if (fpga.ReadFifoU64((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) return ArrayExportU64(data, numberOfElements);
	}
	else {
		list elements;
		if (fpga.ReadFifoU64((uint32_t)fifo, data, (size_t)numberOfElements, (uint32_t)timeout, &elementsRemaining)) elements.append((int)elementsRemaining);
		return elements;
	}
	list emptyList;
	return emptyList;
}

int pynifpga::WriteFifoBool(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoBool((uint32_t)fifo, ArrayImportBool(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoI8(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoI8((uint32_t)fifo, ArrayImportI8(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoU8(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoU8((uint32_t)fifo, ArrayImportU8(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoI16(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoI16((uint32_t)fifo, ArrayImportI16(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoU16(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoU16((uint32_t)fifo, ArrayImportU16(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoI32(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoI32((uint32_t)fifo, ArrayImportI32(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoU32(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoU32((uint32_t)fifo, ArrayImportU32(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoI64(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoI64((uint32_t)fifo, ArrayImportI64(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

int pynifpga::WriteFifoU64(int fifo, list data, int timeout) {
	size_t emptyElementsRemaining=0;
	bool status;
	status = fpga.WriteFifoU64((uint32_t)fifo, ArrayImportU64(data), (size_t)len(data), (uint32_t)timeout, &emptyElementsRemaining);
	return emptyElementsRemaining;
}

list pynifpga::AcquireFifoReadElementsBool(int fifo, int elementsRequested, int timeout) {
	NiFpga_Bool** data = new NiFpga_Bool*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsBool((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportBool(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsI8(int fifo, int elementsRequested, int timeout) {
	int8_t** data = new int8_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsI8((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportI8(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsU8(int fifo, int elementsRequested, int timeout) {
	uint8_t** data = new uint8_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsU8((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportU8(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsI16(int fifo, int elementsRequested, int timeout) {
	int16_t** data = new int16_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsI16((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportI16(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsU16(int fifo, int elementsRequested, int timeout) {
	uint16_t** data = new uint16_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsU16((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportU16(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsI32(int fifo, int elementsRequested, int timeout) {
	int32_t** data = new int32_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsI32((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportI32(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsU32(int fifo, int elementsRequested, int timeout) {
	uint32_t** data = new uint32_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsU32((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportU32(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsI64(int fifo, int elementsRequested, int timeout) {
	int64_t** data = new int64_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsI64((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportI64(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

list pynifpga::AcquireFifoReadElementsU64(int fifo, int elementsRequested, int timeout) {
	uint64_t** data = new uint64_t*[elementsRequested];
	size_t elementsAcquired;
	size_t elementsRemaining;
	if (fpga.AcquireFifoReadElementsU64((uint32_t)fifo, data, (size_t)elementsRequested, (uint32_t)timeout, &elementsAcquired, &elementsRemaining)) return ArrayExportU64(*data, (int)elementsAcquired);
	list emptyList;
	return emptyList;
}

bool pynifpga::AcquireFifoWriteElementsBool(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsBool((uint32_t)fifo, (NiFpga_Bool**)ArrayImportBool(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired==elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsI8(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsI8((uint32_t)fifo, (int8_t**)ArrayImportI8(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsU8(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsU8((uint32_t)fifo, (uint8_t**)ArrayImportU8(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsI16(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsI16((uint32_t)fifo, (int16_t**)ArrayImportI16(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsU16(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsU16((uint32_t)fifo, (uint16_t**)ArrayImportU16(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsI32(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsI32((uint32_t)fifo, (int32_t**)ArrayImportI32(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsU32(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsU32((uint32_t)fifo, (uint32_t**)ArrayImportU32(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsI64(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsI64((uint32_t)fifo, (int64_t**)ArrayImportI64(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::AcquireFifoWriteElementsU64(int fifo, list elements, int elementsRequested, int timeout) {
	size_t elementsAcquired;
	size_t elementsRemaining;
	bool status;
	status = fpga.AcquireFifoWriteElementsU64((uint32_t)fifo, (uint64_t**)ArrayImportU64(elements), (size_t)len(elements), (uint32_t)timeout, &elementsAcquired, &elementsRemaining);
	return status && elementsAcquired == elementsRemaining;
}

bool pynifpga::ReleaseFifoElements(int fifo, int elements) {
	return fpga.ReleaseFifoElements((uint32_t)fifo, (size_t)elements);
}

int pynifpga::GetPeerToPeerFifoEndpoint(int fifo) {
	uint32_t endpoint;
	if (fpga.GetPeerToPeerFifoEndpoint((uint32_t)fifo, &endpoint)) return (int)endpoint;
	return 0;
}
